<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Build a Technical Documentation Page</title>
    <link rel="stylesheet" href="main.css" />
  </head>
  <body>
    <nav id="navbar">
      <header id="nav-header">Asynchronous JavaScript</header>
      <a href="#asynchronous_javascript_overview" class="nav-link">Asynchronous JavaScript overview</a>
      <a href="#introducing_asynchronous_javascript" class="nav-link">Introducing asynchronous JavaScript</a>
      <a href="#how_to_use_promises" class="nav-link">How to use promises</a>
      <a href="#implementing_a_promise-based_api" class="nav-link">Implementing a promise-based API</a>
      <a href="#introducing_workers" class="nav-link">Introducing workers</a>
    </nav>
    <main id="main-doc">
      <!-- Start Section -->
      <section class="main-section">
        <header id="asynchronous_javascript_overview">
          <h1>Asynchronous JavaScript overview</h1>
          <p>
            In this module, we take a look at asynchronous JavaScript, why it is important, and how it can be used to effectively handle potential blocking operations, such as fetching resources from
            a server.
          </p>
        </header>
        <!-- Start Article -->
        <article>
          <h2>Prerequisites</h2>
          <p>Asynchronous JavaScript is a fairly advanced topic, and you are advised to work through JavaScript first steps and JavaScript building blocks modules before attempting this.</p>
        </article>
        <!-- End Article -->

        <!-- Start Article -->
        <article>
          <h2>Guides</h2>
          <a href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Introducing" target="”_blank”">Introducing asynchronous JavaScript</a>
          <p>
            In this article, we'll learn about synchronous and asynchronous programming, why we often need to use asynchronous techniques, and the problems related to the way asynchronous functions
            have historically been implemented in JavaScript.
          </p>
          <a href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Promises" target="”_blank”">How to use promises</a>
          <p>Here we'll introduce promises and show how to use promise-based APIs. We'll also introduce the <code>async</code> and <code>await</code> keywords.</p>
          <a href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Implementing_a_promise-based_API" target="”_blank”">Implementing a promise-based API</a>
          <p>This article will outline how to implement your own promise-based API.</p>
          <a href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Introducing_workers" target="”_blank”">Introducing workers</a>
          <p>Workers enable you to run certain tasks in a separate thread to keep your main code responsive. In this article, we'll rewrite a long-running synchronous function to use a worker.</p>
        </article>
        <!-- End Article -->

        <!-- Start Article -->
        <article>
          <h2>Assessments</h2>
          <a href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Sequencing_animations">Sequencing animations</a>
          <p>The assessment asks you to use promises to play a set of animations in a particular sequence.</p>
        </article>
        <!-- End Article -->

        <!-- Start Article -->
        <article>
          <h2>See also</h2>
          <a href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Sequencing_animations">Sequencing animations</a>
          <p>
            <a href="https://eloquentjavascript.net/11_async.html">Asynchronous Programming</a> from the fantastic <a href="https://eloquentjavascript.net/">Eloquent JavaScript</a> online book by
            Marijn Haverbeke.
          </p>
        </article>
        <!-- End Article -->
      </section>
      <!-- End Section -->

      <!-- Start Section -->
      <section class="main-section">
        <header id="introducing_asynchronous_javascript">
          <h1>Introducing asynchronous JavaScript</h1>
          <p>
            In this article, we'll explain what asynchronous programming is, why we need it, and briefly discuss some of the ways asynchronous functions have historically been implemented in
            JavaScript
          </p>
        </header>
        <!-- Start Article -->
        <article>
          <table>
            <tr>
              <td>Prerequisites:</td>
              <td>Basic computer literacy, a reasonable understanding of JavaScript fundamentals, how to use promise-based APIs.</td>
            </tr>
            <tr>
              <td>Objective</td>
              <td>To test understanding of how to use promise-based APIs.</td>
            </tr>
          </table>
          <p>
            Asynchronous programming is a technique that enables your program to start a potentially long-running task and still be able to be responsive to other events while that task runs, rather
            than having to wait until that task has finished. Once that task has finished, your program is presented with the result.
          </p>
          <p>Many functions provided by browsers, especially the most interesting ones, can potentially take a long time, and therefore, are asynchronous. For example:</p>
          <ul>
            <li>Making HTTP requests using <a href="https://developer.mozilla.org/en-US/docs/Web/API/fetch" target="”_blank”">fetch()</a></li>
            <li>Accessing a user's camera or microphone using <a href="https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia" target="”_blank”">getUserMedia()</a></li>
            <li>Asking a user to select files using <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/showOpenFilePicker" target="”_blank”">showOpenFilePicker()</a></li>
          </ul>
          <p>So even though you may not have to implement your own asynchronous functions very often, you are very likely to need to use them correctly.</p>
          <p>In this article, we'll start by looking at the problem with long-running synchronous functions, which make asynchronous programming a necessity.</p>
        </article>
        <!-- End Article -->

        <!-- Start Article -->
        <article>
          <h2>Synchronous programming</h2>
          <p>Consider the following code:</p>
          <pre>
            <code>
const name = 'Miriam';
const greeting = `Hello, my name is ${name}!`;
console.log(greeting);
// "Hello, my name is Miriam!"
            </code>
          </pre>
          <p>This code:</p>
          <ol>
            <li>Declares a string called <code>name</code>.</li>
            <li>Declares another string called <code>greeting</code>, which uses <code>name</code>.</li>
            <li>Outputs the greeting to the JavaScript console.</li>
          </ol>
          <p>
            We should note here that the browser effectively steps through the program one line at a time, in the order we wrote it. At each point, the browser waits for the line to finish its work
            before going on to the next line. It has to do this because each line depends on the work done in the preceding lines.
          </p>
          <p>That makes this a synchronous program. It would still be synchronous even if we called a separate function, like this:</p>
          <p>Here, makeGreeting() is a synchronous function because the caller has to wait for the function to finish its work and return a value before the caller can continue.</p>
        </article>
        <!-- End Article -->

        <!-- Start Article -->
        <article>
          <h2>A long-running synchronous function</h2>
          <p>What if the synchronous function takes a long time?</p>
          <p>
            The program below uses a very inefficient algorithm to generate multiple large prime numbers when a user clicks the "Generate primes" button. The higher the number of primes a user
            specifies , the longer the operation will take.
          </p>
          <pre>
            <code>
&lt;label for="quota"&gt;Number of primes:&lt;/label&gt;
&lt;input type="text" id="quota" name="quota" value="1000000" /&gt;

&lt;button id="generate"&gt;Generate primes&lt;/button&gt;
&lt;button id="reload"&gt;Reload&lt;/button &gt;

&lt;div id="output"&gt;&lt;/div&gt;
            </code>
          </pre>
          <pre>
            <code>
const MAX_PRIME = 1000000;

function isPrime(n) {
  for (let i = 2; i &lt;= Math.sqrt(n); i++) {
    if (n % i === 0) {
      return false;
    }
  }
  return n > 1;
}

const random = (max) => Math.floor(Math.random() * max);

function generatePrimes(quota) {
  const primes = [];
  while (primes.length &lt; quota) {
    const candidate = random(MAX_PRIME);
    if (isPrime(candidate)) {
      primes.push(candidate);
    }
  }
  return primes;
}

const quota = document.querySelector('#quota');
const output = document.querySelector('#output');

document.querySelector('#generate').addEventListener('click', () => {
  const primes = generatePrimes(quota.value);
  output.textContent = `Finished generating ${quota.value} primes!`;
});

document.querySelector('#reload').addEventListener('click', () => {
  document.location.reload();
});
              </code>
          </pre>
        </article>
        <!-- End Article -->

        <!-- Start Article -->
        <article>
          <h1>Event handlers</h1>
          <p>
            The description we just saw of asynchronous functions might remind you of event handlers, and if it does, you'd be right. Event handlers are really a form of asynchronous programming: you
            provide a function (the event handler) that will be called, not right away, but whenever the event happens. If "the event" is "the asynchronous operation has completed", then that event
            could be used to notify the caller about the result of an asynchronous function call.
          </p>
          <p>
            Some early asynchronous APIs used events in just this way. The <a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest" target="_blank">XMLHttpRequest</a> API enables you
            to make HTTP requests to a remote server using JavaScript. Since this can take a long time, it's an asynchronous API, and you get notified about the progress and eventual completion of a
            request by attaching event listeners to the <code>XMLHttpRequest</code> object.
          </p>
          <p>
            The following example shows this in action. Press "Click to start request" to send a request. We create a new
            <a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest" target="_blank">XMLHttpRequest</a> and listen for its
            <a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/loadend_event" target="_blank">loadend</a> event. The handler logs a "Finished!" message along with the status
            code.
          </p>
          <p>
            After adding the event listener we send the request. Note that after this, we can log "Started XHR request": that is, our program can continue to run while the request is going on, and our
            event handler will be called when the request is complete.
          </p>
          <pre>
            <code>
&lt;button id="xhr"&gt;Click to start request&lt;/button&gt;
&lt;button id="reload"&gt;Reload&lt;/button&gt;

&lt;pre readonly class="event-log"&gt;&lt;/pre&gt;
            </code>
          </pre>
          <pre>
            <code>
const log = document.querySelector('.event-log');

document.querySelector('#xhr').addEventListener('click', () => {
  log.textContent = '';

  const xhr = new XMLHttpRequest();

  xhr.addEventListener('loadend', () => {
    log.textContent = `${log.textContent}Finished with status: ${xhr.status}`;
  });

  xhr.open('GET', 'https://raw.githubusercontent.com/mdn/content/main/files/en-us/_wikihistory.json');
  xhr.send();
  log.textContent = `${log.textContent}Started XHR request\n`;});

document.querySelector('#reload').addEventListener('click', () => {
  log.textContent = '';
  document.location.reload();
});
            </code>
          </pre>
          <p>
            This is just like the <a href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events" target="_blank">event handlers we've encountered in a previous module</a>,
            except that instead of the event being a user action, such as the user clicking a button, the event is a change in the state of some object.
          </p>
        </article>
        <!-- End Article -->

        <!-- Start Article -->
        <article>
          <h2>Callbacks</h2>
          <p>
            An event handler is a particular type of callback. A callback is just a function that's passed into another function, with the expectation that the callback will be called at the
            appropriate time. As we just saw, callbacks used to be the main way asynchronous functions were implemented in JavaScript.
          </p>
          <p>
            However, callback-based code can get hard to understand when the callback itself has to call functions that accept a callback. This is a common situation if you need to perform some
            operation that breaks down into a series of asynchronous functions. For example, consider the following:
          </p>
          <pre>
            <code>
function doStep1(init) {
  return init + 1;
}

function doStep2(init) {
  return init + 2;
}

function doStep3(init) {
  return init + 3;
}

function doOperation() {
  let result = 0;
  result = doStep1(result);
  result = doStep2(result);
  result = doStep3(result);
  console.log(`result: ${result}`);
}

doOperation();
            </code>
          </pre>
          <p>
            Here we have a single operation that's split into three steps, where each step depends on the last step. In our example, the first step adds 1 to the input, the second adds 2, and the
            third adds 3. Starting with an input of 0, the end result is 6 (0 + 1 + 2 + 3). As a synchronous program, this is very straightforward. But what if we implemented the steps using
            callbacks?
          </p>
          <pre>
            <code>
function doStep1(init, callback) {
  const result = init + 1;
  callback(result);
}

function doStep2(init, callback) {
  const result = init + 2;
  callback(result);
}

function doStep3(init, callback) {
  const result = init + 3;
  callback(result);
}

function doOperation() {
  doStep1(0, (result1) => {
    doStep2(result1, (result2) => {
      doStep3(result2, (result3) => {
        console.log(`result: ${result3}`);
      });
    });
  });
}

doOperation();
            </code>
          </pre>
          <p>
            Because we have to call callbacks inside callbacks, we get a deeply nested <code>doOperation()</code> function, which is much harder to read and debug. This is sometimes called "callback
            hell" or the "pyramid of doom" (because the indentation looks like a pyramid on its side).
          </p>
          <p>
            When we nest callbacks like this, it can also get very hard to handle errors: often you have to handle errors at each level of the "pyramid", instead of having error handling only once at
            the top level.
          </p>
          <p>
            For these reasons, most modern asynchronous APIs don't use callbacks. Instead, the foundation of asynchronous programming in JavaScript is the <a href="" target="_blank">Promise</a>, and
            that's the subject of the next article.
          </p>
        </article>
        <!-- End Article -->
      </section>
      <!-- End Section -->

      <!-- Start Section -->
      <section class="main-section">
        <header id="how_to_use_promises">
          <h1>How to use promises</h1>
          <p>
            <b>Promises</b> are the foundation of asynchronous programming in modern JavaScript. A promise is an object returned by an asynchronous function, which represents the current state of the
            operation. At the time the promise is returned to the caller, the operation often isn't finished, but the promise object provides methods to handle the eventual success or failure of the
            operation.
          </p>
        </header>
        <article>
          <table>
            <tr>
              <td>Prerequisites:</td>
              <td>Basic computer literacy, a reasonable understanding of JavaScript fundamentals, including event handling.</td>
            </tr>
            <tr>
              <td>Objective</td>
              <td>To understand how to use promises in JavaScript.</td>
            </tr>
          </table>
          <p>
            In the last article, we talked about the use of callbacks to implement asynchronous functions. With that design, you call the asynchronous function, passing in your callback function. The
            function returns immediately and calls your callback when the operation is finished.
          </p>
          <p>
            With a promise-based API, the asynchronous function starts the operation and returns a
            <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank">Promise</a> object. You can then attach handlers to this promise object,
            and these handlers will be executed when the operation has succeeded or failed.
          </p>
        </article>
        <article>
          <h2>Using the fetch() API</h2>
          <p><strong>Note</strong>: In this article, we will explore promises by copying code samples from the page into your browser's JavaScript console. To set this up:</p>
          <ol>
            <li>open a browser tab and visit <a href="https://example.org/" target="_blank">https://example.org</a></li>
            <li>
              in that tab, open the JavaScript console in your <a href="https://developer.mozilla.org/en-US/docs/Learn/Common_questions/What_are_browser_developer_tools">browser's developer tools</a>
            </li>
            <li>
              when we show an example, copy it into the console. You will have to reload the page each time you enter a new example, or the console will complain that you have redeclared
              <code>fetchPromise</code>.
            </li>
          </ol>
          <p>
            In this example, we'll download the JSON file from
            <a href="https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json"
              >https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json</a
            >, and log some information about it.
          </p>
          <p>
            To do this, we'll make an HTTP request to the server. In an HTTP request, we send a request message to a remote server, and it sends us back a response. In this case, we'll send a request
            to get a JSON file from the server. Remember in the last article, where we made HTTP requests using the
            <a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest">XMLHttpRequest</a> API? Well, in this article, we'll use the
            <a href="https://developer.mozilla.org/en-US/docs/Web/API/fetch">fetch()</a> API, which is the modern, promise-based replacement for <code>XMLHttpRequest</code>.
          </p>
          <p>Copy this into your browser's JavaScript console:</p>
          <pre>
            <code>
const fetchPromise = fetch('https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json');

console.log(fetchPromise);

fetchPromise.then((response) => {
  console.log(`Received response: ${response.status}`);
});

console.log("Started request…");

            </code>
          </pre>
          <p>Here we are:</p>
          <ol>
            <li>calling the <code>fetch()</code> API, and assigning the return value to the <code>fetchPromise</code> variable</li>
            <li>
              immediately after, logging the <code>fetchPromise</code> variable. This should output something like: <code href="">Promise { &lt;state &gt;: "pending" }</code>, telling us that we have
              a <code>Promise</code> object, and it has a <code>state</code> whose value is <code>"pending"</code>. The <code>"pending"</code> state means that the fetch operation is still going on.
            </li>
            <li>
              passing a handler function into the Promise's <code>then()</code> method. When (and if) the fetch operation succeeds, the promise will call our handler, passing in a
              <a href="https://developer.mozilla.org/en-US/docs/Web/API/Response">Response</a> object, which contains the server's response.
            </li>
            <li>logging a message that we have started the request.</li>
          </ol>
          <p>The complete output should be something like:</p>
          <pre>
            <code>
Promise {  	&lt;state&gt;: "pending" }
Started request…
Received response: 200
            </code>
          </pre>
          <p>
            Note that <code>Started request</code>… is logged before we receive the response. Unlike a synchronous function, <code>fetch()</code> returns while the request is still going on, enabling
            our program to stay responsive. The response shows the <code>200</code> (OK) <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status">status code</a>, meaning that our request
            succeeded.
          </p>
          <p>
            This probably seems a lot like the example in the last article, where we added event handlers to the
            <a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest">XMLHttpRequest</a> object. Instead of that, we're passing a handler into the <code>then()</code> method of the
            returned promise.
          </p>
        </article>
        <article>
          <h2>Chaining promises</h2>
          <p>
            With the <code>fetch()</code> API, once you get a <code>Response</code> object, you need to call another function to get the response data. In this case, we want to get the response data
            as JSON, so we would call the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Response/json" target="_blank">json()</a> method of the <code>Response</code> object. It turns out
            that <code>json()</code> is also asynchronous. So this is a case where we have to call two successive asynchronous functions.
          </p>
          <p>Try this:</p>
          <pre>
            <code>
const fetchPromise = fetch('https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json');

fetchPromise.then((response) => {
  const jsonPromise = response.json();
  jsonPromise.then((data) => {
    console.log(data[0].name);
  });
});
              </code>
          </pre>
          <p>
            In this example, as before, we add a <code>then()</code> handler to the promise returned by <code>fetch()</code>. But this time, our handler calls <code>response.json()</code>, and then
            passes a new <code>then()</code> handler into the promise returned by <code>response.json()</code>.
          </p>
          <p>This should log "baked beans" (the name of the first product listed in "products.json").</p>

          <p>
            But wait! Remember the last article, where we said that by calling a callback inside another callback, we got successively more nested levels of code? And we said that this "callback hell"
            made our code hard to understand? Isn't this just the same, only with <code>then()</code> calls?
          </p>
          <p>
            It is, of course. But the elegant feature of promises is that <code>then()</code> itself returns a promise, which will be completed with the result of the function passed to it. This means
            that we can (and certainly should) rewrite the above code like this:
          </p>
          <pre>
          <code>
const fetchPromise = fetch('https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json');

fetchPromise
  .then((response) => response.json())
  .then((data) => {
    console.log(data[0].name);
  });
            </code>
        </pre>
          <p>
            Instead of calling the second <code>then()</code> inside the handler for the first <code>then()</code>, we can return the promise returned by <code>json()</code>, and call the second
            then() on that return value. This is called promise chaining and means we can avoid ever-increasing levels of indentation when we need to make consecutive asynchronous function calls.
          </p>
          <p>
            Before we move on to the next step, there's one more piece to add. We need to check that the server accepted and was able to handle the request, before we try to read it. We'll do this by
            checking the status code in the response and throwing an error if it wasn't "OK":
          </p>
          <pre>
            <code>
const fetchPromise = fetch('https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json');

fetchPromise
  .then((response) => {
    if (!response.ok) {
      throw new Error(`HTTP error: ${response.status}`);
    }
    return response.json();
  })
  .then((data) => {
    console.log(data[0].name);
  });
          </code>
        </pre>
        </article>
        <article>
          <h2>Catching errors</h2>
          <p>
            This brings us to the last piece: how do we handle errors? The <code>fetch()</code> API can throw an error for many reasons (for example, because there was no network connectivity or the
            URL was malformed in some way) and we are throwing an error ourselves if the server returned an error.
          </p>
          <p>In the last article, we saw that error handling can get very difficult with nested callbacks, making us handle errors at every nesting level.</p>
          <p>
            To support error handling, <code>Promise</code> objects provide a
            <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch" target="_blank">catch()</a> method. This is a lot like <code>then()</code>: you
            call it and pass in a handler function. However, while the handler passed to <code>then()</code> is called when the asynchronous operation succeeds, the handler passed to
            <code>catch()</code> is called when the asynchronous operation fails.
          </p>
          <p>
            If you add <code>catch()</code> to the end of a promise chain, then it will be called when any of the asynchronous function calls fails. So you can implement an operation as several
            consecutive asynchronous function calls, and have a single place to handle all errors.
          </p>
          <p>Try this version of our <code>fetch()</code> code. We've added an error handler using <code>catch()</code>, and also modified the URL so the request will fail.</p>
          <pre>
            <code>
const fetchPromise = fetch('bad-scheme://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json');

fetchPromise
  .then((response) => {
    if (!response.ok) {
      throw new Error(`HTTP error: ${response.status}`);
    }
    return response.json();
  })
  .then((data) => {
    console.log(data[0].name);
  })
  .catch((error) => {
    console.error(`Could not get products: ${error}`);
  });
            </code>
          </pre>
          <p>Try running this version: you should see the error logged by our <code>catch()</code> handler.</p>
        </article>
        <article>
          <h2>Promise terminology</h2>
          <p>Promises come with some quite specific terminology that it's worth getting clear about.</p>
          <p>First, a promise can be in one of three states:</p>
          <ul>
            <li>
              <strong>pending</strong>: the promise has been created, and the asynchronous function it's associated with has not succeeded or failed yet. This is the state your promise is in when it's
              returned from a call to <code>fetch()</code>, and the request is still being made.
            </li>
            <li><strong>fulfilled</strong>: the asynchronous function has succeeded. When a promise is fulfilled, its <code>then()</code> handler is called.</li>
            <li><strong>rejected</strong>: the asynchronous function has failed. When a promise is rejected, its <code>catch()</code> handler is called.</li>
          </ul>
          <p>
            Note that what "succeeded" or "failed" means here is up to the API in question: for example, <code>fetch()</code> considers a request successful if the server returned an error like
            <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/404" target="_blank">404 Not Found</a>, but not if a network error prevented the request being sent.
          </p>
          <p>Sometimes, we use the term settled to cover both fulfilled and rejected.</p>
          <p>A promise is resolved if it is settled, or if it has been "locked in" to follow the state of another promise.</p>
          <p>
            The article <a href="https://thenewtoys.dev/blog/2021/02/08/lets-talk-about-how-to-talk-about-promises/" target="_blank">Let's talk about how to talk about promises</a> gives a great
            explanation of the details of this terminology.
          </p>
        </article>
        <article>
          <h2>Combining multiple promises</h2>
          <p>
            The promise chain is what you need when your operation consists of several asynchronous functions, and you need each one to complete before starting the next one. But there are other ways
            you might need to combine asynchronous function calls, and the <code>Promise</code> API provides some helpers for them.
          </p>
          <p>
            Sometimes, you need all the promises to be fulfilled, but they don't depend on each other. In a case like that, it's much more efficient to start them all off together, then be notified
            when they have all fulfilled. The <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all" target="_blank">Promise.all()</a> method is what
            you need here. It takes an array of promises and returns a single promise.
          </p>
          <p>The promise returned by <code> Promise.all()</code> is:</p>
          <ul>
            <li>
              fulfilled when and if all the promises in the array are fulfilled. In this case, the <code>then()</code> handler is called with an array of all the responses, in the same order that the
              promises were passed into <code>all()</code>.
            </li>
            <li>rejected when and if any of the promises in the array are rejected. In this case, the <code>catch()</code> handler is called with the error thrown by the promise that rejected.</li>
          </ul>
          <p>For example:</p>
          <pre>
            <code>
const fetchPromise1 = fetch('https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json');
const fetchPromise2 = fetch('https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/not-found');
const fetchPromise3 = fetch('https://mdn.github.io/learning-area/javascript/oojs/json/superheroes.json');

Promise.all([fetchPromise1, fetchPromise2, fetchPromise3])
  .then((responses) => {
    for (const response of responses) {
      console.log(`${response.url}: ${response.status}`);
    }
  })
  .catch((error) => {
    console.error(`Failed to fetch: ${error}`)
  });
            </code>
          </pre>
          <p>
            Here, we're making three <code>fetch()</code> requests to three different URLs. If they all succeed, we will log the response status of each one. If any of them fail, then we're logging
            the failure.
          </p>
          <p>
            With the URLs we've provided, all the requests should be fulfilled, although for the second, the server will return <code>404</code> (Not Found) instead of <code>200</code> (OK) because
            the requested file does not exist. So the output should be:
          </p>
          <pre>
            <code>
https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json: 200
https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/not-found: 404
https://mdn.github.io/learning-area/javascript/oojs/json/superheroes.json: 200
            </code>
          </pre>
          <p>If we try the same code with a badly formed URL, like this:</p>
          <pre>
            <code>
const fetchPromise1 = fetch('https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json');
const fetchPromise2 = fetch('https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/not-found');
const fetchPromise3 = fetch('bad-scheme://mdn.github.io/learning-area/javascript/oojs/json/superheroes.json');

Promise.all([fetchPromise1, fetchPromise2, fetchPromise3])
  .then((responses) => {
    for (const response of responses) {
      console.log(`${response.url}: ${response.status}`);
    }
  })
  .catch((error) => {
    console.error(`Failed to fetch: ${error}`)
  });
            </code>
          </pre>
          <p>Then we can expect the <code>catch()</code> handler to run, and we should see something like:</p>
          <pre>
            <code>
Failed to fetch: TypeError: Failed to fetch
            </code>
          </pre>
          <p>
            Sometimes, you might need any one of a set of promises to be fulfilled, and don't care which one. In that case, you want
            <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/any" target="_blank">Promise.any()</a>. This is like <code>Promise.all()</code>, except
            that it is fulfilled as soon as any of the array of promises is fulfilled, or rejected if all of them are rejected:
          </p>
          <pre>
            <code>
const fetchPromise1 = fetch('https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json');
const fetchPromise2 = fetch('https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/not-found');
const fetchPromise3 = fetch('https://mdn.github.io/learning-area/javascript/oojs/json/superheroes.json');

Promise.any([fetchPromise1, fetchPromise2, fetchPromise3])
  .then((response) => {
    console.log(`${response.url}: ${response.status}`);
  })
  .catch((error) => {
    console.error(`Failed to fetch: ${error}`)
  });
            </code>
          </pre>
          <p>Note that in this case we can't predict which fetch request will complete first.</p>
          <p>
            These are just two of the extra <code>Promise</code> functions for combining multiple promises. To learn about the rest, see the
            <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank">Promise</a> reference documentation.
          </p>
        </article>
        <article>
          <h2>async and await</h2>
          <p>
            The <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function" target="_blank">async</a> keyword gives you a simpler way to work with
            asynchronous promise-based code. Adding <code>async</code> at the start of a function makes it an async function:
          </p>
          <pre>
            <code>
async function myFunction() {
  // This is an async function
}              
            </code>
          </pre>
          <p>
            Inside an async function, you can use the <code>await</code> keyword before a call to a function that returns a promise. This makes the code wait at that point until the promise is
            settled, at which point the fulfilled value of the promise is treated as a return value, or the rejected value is thrown.
          </p>
          <p>This enables you to write code that uses asynchronous functions but looks like synchronous code. For example, we could use it to rewrite our fetch example:</p>
          <pre>
            <code>
async function fetchProducts() {
  try {
    // after this line, our function will wait for the `fetch()` call to be settled
    // the `fetch()` call will either return a Response or throw an error
    const response = await fetch('https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json');
    if (!response.ok) {
      throw new Error(`HTTP error: ${response.status}`);
    }
    // after this line, our function will wait for the `response.json()` call to be settled
    // the `response.json()` call will either return the parsed JSON object or throw an error
    const data = await response.json();
    console.log(data[0].name);
  }
  catch (error) {
    console.error(`Could not get products: ${error}`);
  }
}

fetchProducts();
            </code>
          </pre>
          <p>
            Here, we are calling <code>await fetch()</code>, and instead of getting a <code>Promise</code>, our caller gets back a fully complete <code>Response</code> object, just as if
            <code>fetch()</code> were a synchronous function!
          </p>
          <p>We can even use a <code>try...catch</code> block for error handling, exactly as we would if the code were synchronous.</p>
          <p>Note though that async functions always return a promise, so you can't do something like:</p>
          <pre>
            <code>
async function fetchProducts() {
  try {
    const response = await fetch('https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json');
    if (!response.ok) {
      throw new Error(`HTTP error: ${response.status}`);
    }
    const data = await response.json();
    return data;
  }
  catch (error) {
    console.error(`Could not get products: ${error}`);
  }
}

const promise = fetchProducts();
console.log(promise[0].name);   // "promise" is a Promise object, so this will not work
            </code>
          </pre>
          <p>Instead, you'd need to do something like:</p>
          <pre>
            <code>
async function fetchProducts() {
  try {
    const response = await fetch('https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json');
    if (!response.ok) {
      throw new Error(`HTTP error: ${response.status}`);
    }
    const data = await response.json();
    return data;
  }
  catch (error) {
    console.error(`Could not get products: ${error}`);
  }
}

const promise = fetchProducts();
promise.then((data) => console.log(data[0].name));
            </code>
          </pre>
          <p>
            Also, note that you can only use <code>await</code> inside an <code>async</code> function, unless your code is in a
            <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules" target="_blank">JavaScript module</a>. That means you can't do this in a normal script:
          </p>
          <pre>
            <code>
try {
  // using await outside an async function is only allowed in a module
  const response = await fetch('https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json');
  if (!response.ok) {
    throw new Error(`HTTP error: ${response.status}`);
  }
  const data = await response.json();
  console.log(data[0].name);
}
catch(error) {
  console.error(`Could not get products: ${error}`);
}          
            </code>
          </pre>
          <p>You'll probably use <code>async</code> functions a lot where you might otherwise use promise chains, and they make working with promises much more intuitive.</p>
          <p>
            Keep in mind that just like a promise chain, <code>await</code> forces asynchronous operations to be completed in series. This is necessary if the result of the next operation depends on
            the result of the last one, but if that's not the case then something like <code>Promise.all()</code> will be more performant.
          </p>
        </article>
      </section>
      <!-- End Section  -->

      <!-- Start Section -->
      <section class="main-section">
        <header id="implementing_a_promise-based_api">
          <h1>Implementing a promise-based API</h1>
          <p>
            n the last article we discussed how to use APIs that return promises. In this article we'll look at the other side — how to implement APIs that return promises. This is a much less common
            task than using promise-based APIs, but it's still worth knowing about.
          </p>
        </header>
        <article>
          <table>
            <tr>
              <td>Prerequisites:</td>
              <td>Basic computer literacy, a reasonable understanding of JavaScript fundamentals, including event handling and the basics of promises.</td>
            </tr>
            <tr>
              <td>Objective</td>
              <td>To understand how to implement promise-based APIs.</td>
            </tr>
          </table>
          <p>
            Generally, when you implement a promise-based API, you'll be wrapping an asynchronous operation, which might use events, or plain callbacks, or a message-passing model. You'll arrange for
            a <code>Promise</code> object to handle the success or failure of that operation properly.
          </p>
        </article>
        <article>
          <h2>Implementing an alarm() API</h2>
          <p>
            In this example we'll implement a promise-based alarm API, called <code>alarm()</code>. It will take as arguments the name of the person to wake up and a delay in milliseconds to wait
            before waking the person up. After the delay, the function will send a "Wake up!" message, including the name of the person we need to wake up.
          </p>
          <h3>Wrapping setTimeout()</h3>
          <p>
            We'll use the <a href="https://developer.mozilla.org/en-US/docs/Web/API/setTimeout" target="_blank">setTimeout()</a> API to implement our <code>alarm()</code> function. The
            <code>setTimeout()</code>
            API takes as arguments a callback function and a delay, given in milliseconds. When <code>setTimeout()</code> is called, it starts a timer set to the given delay, and when the time
            expires, it calls the given function.
          </p>
          <p>In the example below, we call <code>setTimeout()</code> with a callback function and a delay of 1000 milliseconds:</p>
          <pre>
            <code>
&lt;button id="set-alarm"&gt;Set alarm&lt;/button&gt;
&lt;div id="output"&gt;&lt;/div&gt;
            </code>
          </pre>
          <pre>
            <code>
const output = document.querySelector('#output');
const button = document.querySelector('#set-alarm');

function setAlarm() {
  setTimeout(() => {
    output.textContent = 'Wake up!';
  }, 1000);
}

button.addEventListener('click', setAlarm);
            </code>
          </pre>
          <h3>The Promise() constructor</h3>
          <p>
            Our <code>alarm()</code> function will return a <code>Promise</code> that is fulfilled when the timer expires. It will pass a "Wake up!" message into the <code>then()</code> handler, and
            will reject the promise if the caller supplies a negative delay value.
          </p>
          <p>
            The key component here is the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/Promise" target="_blank">Promise()</a> constructor. The
            <code>Promise()</code> constructor takes a single function as an argument. We'll call this function the <code>executor</code>. When you create a new promise you supply the implementation
            of the executor.
          </p>
          <p>
            This executor function itself takes two arguments, which are both also functions, and which are conventionally called <code>resolve</code> and <code>reject</code>. In your executor
            implementation, you call the underlying asynchronous function. If the asynchronous function succeeds, you call <code>resolve</code>, and if it fails, you call <code>reject</code>. If the
            executor function throws an error, <code>reject</code> is called automatically. You can pass a single parameter of any type into <code>resolve</code> and <code>reject</code>.
          </p>
          <p>So we can implement <code>alarm()</code> like this:</p>
          <pre>
            <code>
function alarm(person, delay) {
  return new Promise((resolve, reject) => {
    if (delay &lt; 0) {
      throw new Error('Alarm delay must not be negative');
    }
    setTimeout(() => {
      resolve(`Wake up, ${person}!`);
    }, delay);
  });
}    
            </code>
          </pre>
          <p>This function creates and returns a new <code>Promise</code>. Inside the executor for the promise, we:</p>
          <ul>
            <li>check that <code>delay</code> is not negative, and throw an error if it is.</li>
            <li>
              call <code>setTimeout()</code>, passing a callback and <code>delay</code>. The callback will be called when the timer expires, and in the callback we call <code>resolve</code>, passing
              in our <code>"Wake up!"</code> message.
            </li>
          </ul>
        </article>
        <article>
          <h2>Using the alarm() API</h2>
          <p>
            This part should be quite familiar from the last article. We can call <code>alarm()</code>, and on the returned promise call <code>then()</code> and <code>catch()</code> to set handlers
            for promise fulfillment and rejection.
          </p>
          <pre>
            <code>
const name = document.querySelector('#name');
const delay = document.querySelector('#delay');
const button = document.querySelector('#set-alarm');
const output = document.querySelector('#output');

function alarm(person, delay) {
  return new Promise((resolve, reject) => {
    if (delay < 0) {
      throw new Error('Alarm delay must not be negative');
    }
    setTimeout(() => {
      resolve(`Wake up, ${person}!`);
    }, delay);
  });
}

button.addEventListener('click', () => {
  alarm(name.value, delay.value)
    .then((message) => output.textContent = message)
    .catch((error) => output.textContent = `Couldn't set alarm: ${error}`);
});
            </code>
          </pre>
        </article>
        <article>
          <h2>Using async and await with the alarm() API</h2>
          <p>
            Since <code>alarm()</code> returns a <code>Promise</code>, we can do everything with it that we could do with any other promise: promise chaining, <code>Promise.all()</code>, and
            <code>async</code> / <code>await</code>:
          </p>
          <code>
            <pre>
const name = document.querySelector('#name');
const delay = document.querySelector('#delay');
const button = document.querySelector('#set-alarm');
const output = document.querySelector('#output');

function alarm(person, delay) {
  return new Promise((resolve, reject) => {
    if (delay < 0) {
      throw new Error('Alarm delay must not be negative');
    }
    setTimeout(() => {
      resolve(`Wake up, ${person}!`);
    }, delay);
  });
}

button.addEventListener('click', async () => {
  try {
    const message = await alarm(name.value, delay.value);
    output.textContent = message;
  }
  catch (error) {
    output.textContent = `Couldn't set alarm: ${error}`;
  }
});
            </pre>
          </code>
        </article>
      </section>
      <!-- End Section -->

      <!-- Start Section -->
      <section class="main-section">
        <header id="introducing_workers">
          <h2>Introducing workers</h2>
          <p>
            In this final article in our "Asynchronous JavaScript" module, we'll introduce workers, which enable you to run some tasks in a separate
            <a href="https://developer.mozilla.org/en-US/docs/Glossary/Thread" target="_blank">thread</a> of execution.
          </p>
        </header>
        <article>
          <table>
            <tr>
              <td>Prerequisites:</td>
              <td>Basic computer literacy, a reasonable understanding of JavaScript fundamentals, including event handling.</td>
            </tr>
            <tr>
              <td>Objective</td>
              <td>To understand how to use web workers.</td>
            </tr>
          </table>
          <p>
            In the first article of this module, we saw what happens when you have a long-running synchronous task in your program — the whole window becomes totally unresponsive. Fundamentally, the
            reason for this is that the program is single-threaded. A thread is a sequence of instructions that a program follows. Because the program consists of a single thread, it can only do one
            thing at a time: so if it is waiting for our long-running synchronous call to return, it can't do anything else.
          </p>
          <p>Workers give you the ability to run some tasks in a different thread, so you can start the task, then continue with other processing (such as handling user actions).</p>
          <p>
            But there's a price to pay for this. With multithreaded code, you never know when your thread will be suspended and the other thread will get a chance to run. So if both threads have
            access to the same variables, it's possible for a variable to change unexpectedly at any time, and this causes bugs that are hard to find.
          </p>
          <p>
            To avoid these problems on the web, your main code and your worker code never get direct access to each other's variables. Workers and the main code run in completely separate worlds, and
            only interact by sending each other messages. In particular, this means that workers can't access the DOM (the window, document, page elements, and so on).
          </p>
          <p>There are three different sorts of workers:</p>
          <ul>
            <li>dedicated workers</li>
            <li>shared workers</li>
            <li>service workers</li>
          </ul>
          <p>In this article, we'll walk through an example of the first sort of worker, then briefly discuss the other two.</p>
        </article>
        <article>
          <h2>Using web workers</h2>
          <p>
            Remember in the first article, where we had a page that calculated prime numbers? We're going to use a worker to run the prime-number calculation, so our page stays responsive to user
            actions.
          </p>
          <h3>The synchronous prime generator</h3>
          <p>Let's first take another look at the JavaScript in our previous example:</p>
          <pre>
            <code>
function generatePrimes(quota) {

  function isPrime(n) {
    for (let c = 2; c &lt;= Math.sqrt(n); ++c) {
      if (n % c === 0) {
          return false;
        }
    }
    return true;
  }

  const primes = [];
  const maximum = 1000000;

  while (primes.length &lt; quota) {
    const candidate = Math.floor(Math.random() * (maximum + 1));
    if (isPrime(candidate)) {
      primes.push(candidate);
    }
  }

  return primes;
}

document.querySelector('#generate').addEventListener('click', () => {
  const quota = document.querySelector('#quota').value;
  const primes = generatePrimes(quota);
  document.querySelector('#output').textContent = `Finished generating ${quota} primes!`;
});

document.querySelector('#reload').addEventListener('click', () => {
  document.querySelector('#user-input').value = 'Try typing in here immediately after pressing "Generate primes"';
  document.location.reload();
});
            </code>
          </pre>
          <p>In this program, after we call <code>generatePrimes()</code>, the program becomes totally unresponsive.</p>
          <h3>Prime generation with a worker</h3>
          <p>
            For this example, start by making a local copy of the files at
            <a href="https://github.com/mdn/learning-area/tree/main/javascript/asynchronous/workers/start" target="_blank"
              >https://github.com/mdn/learning-area/blob/main/javascript/asynchronous/workers/start</a
            >. There are four files in this directory:
          </p>
          <ul>
            <li>index.html</li>
            <li>style.css</li>
            <li>main.js</li>
            <li>generate.js</li>
          </ul>
          <p>The "index.html" file and the "style.css" files are already complete:</p>
          <pre>
            <code>
&lt;!DOCTYPE html>
&lt;html lang="en-US">
  &lt;head>
    &lt;meta charset="utf-8" />
    &lt;meta name="viewport" content="width=device-width" />
    &lt;title>Prime numbers</title>
    &lt;script src="main.js" defer></script>
    &lt;link href="style.css" rel="stylesheet" />
  &lt;/head>

  &lt;body>
    &lt;label for="quota">Number of primes:</label>
    &lt;input type="text" id="quota" name="quota" value="1000000" />

    &lt;button id="generate">Generate primes</button>
    &lt;button id="reload">Reload</button>

    &lt;textarea id="user-input" rows="5" cols="62">
      Try typing in here immediately after pressing "Generate primes"
    &lt;/textarea>

    &lt;div id="output"></div>
  &lt;/body>
&lt;/html>
            </code>
          </pre>
          <pre>
            <code>
textarea {
  display: block;
  margin: 1rem 0;
}              
            </code>
          </pre>
          <p>The "main.js" and "generate.js" files are empty. We're going to add the main code to "main.js", and the worker code to "generate.js".</p>
          <p>So first, we can see that the worker code is kept in a separate script from the main code. We can also see, looking at "index.html" above, that only the main code is included in a <code>&lt;script&gt;</code> element.</p>
          <p>Now copy the following code into "main.js":</p>
          <pre>
            <code>
// Create a new worker, giving it the code in "generate.js"
const worker = new Worker('./generate.js');

// When the user clicks "Generate primes", send a message to the worker.
// The message command is "generate", and the message also contains "quota",
// which is the number of primes to generate.
document.querySelector('#generate').addEventListener('click', () => {
  const quota = document.querySelector('#quota').value;
  worker.postMessage({
    command: 'generate',
    quota,
  });
});

// When the worker sends a message back to the main thread,
// update the output box with a message for the user, including the number of
// primes that were generated, taken from the message data.
worker.addEventListener('message', (message) => {
  document.querySelector('#output').textContent = `Finished generating ${message.data} primes!`;
});

document.querySelector('#reload').addEventListener('click', () => {
  document.querySelector('#user-input').value = 'Try typing in here immediately after pressing "Generate primes"';
  document.location.reload();
});
            </code>
          </pre>
          <ul>
            <li>First, we're creating the worker using the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Worker/Worker" target="_blank">Worker()</a> constructor. We pass it a URL pointing to the worker script. As soon as the worker is created, the worker script is executed.</li>
            <li>Next, as in the synchronous version, we add a <code>click</code> event handler to the "Generate primes" button. But now, rather than calling a <code>generatePrimes()</code> function, we send a message to the worker using <a href="https://developer.mozilla.org/en-US/docs/Web/API/Worker/postMessage" target="_blank">worker.postMessage()</a>. This message can take an argument, and in this case, we're passing a JSON object containing two properties: 
              <ul>
                <li><code>command</code>: a string identifying the thing we want the worker to do (in case our worker could do more than one thing)</li>
                <li><code>quota</code>: the number of primes to generate.</li>
              </ul>
            </li>
            <li>Next, we add a <code>message</code> event handler to the worker. This is so the worker can tell us when it has finished, and pass us any resulting data. Our handler takes the data from the <code>data</code> property of the message, and writes it to the output element (the data is exactly the same as <code>quota</code>, so this is a bit pointless, but it shows the principle).</li>
            <li>Finally, we implement the <code>click</code> event handler for the "Reload" button. This is exactly the same as in the synchronous version.</li>
          </ul>
          <p>Now for the worker code. Copy the following code into "generate.js":</p>
          <pre>
            <code>
// Listen for messages from the main thread.
// If the message command is "generate", call `generatePrimes()`
addEventListener("message", (message) => {
  if (message.data.command === 'generate') {
    generatePrimes(message.data.quota);
  }
});

// Generate primes (very inefficiently)
function generatePrimes(quota) {

  function isPrime(n) {
    for (let c = 2; c &lt;= Math.sqrt(n); ++c) {
      if (n % c === 0) {
          return false;
       }
    }
    return true;
  }

  const primes = [];
  const maximum = 1000000;

  while (primes.length &lt; quota) {
    const candidate = Math.floor(Math.random() * (maximum + 1));
    if (isPrime(candidate)) {
      primes.push(candidate);
    }
  }

  // When we have finished, send a message to the main thread,
  // including the number of primes we generated.
  postMessage(primes.length);
}
            </code>
          </pre>
          <p>Remember that this runs as soon as the main script creates the worker.</p>
          <p>The first thing the worker does is start listening for messages from the main script. It does this using <code>addEventListener()</code>, which is a global function in a worker. Inside the <code>message</code> event handler, the <code>data</code> property of the event contains a copy of the argument passed from the main script. If the main script passed the <code>generate</code> command, we call <code>generatePrimes()</code>, passing in the <code>quota</code> value from the message event.</p>
          <p>The <code>generatePrimes()</code> function is just like the synchronous version, except instead of returning a value, we send a message to the main script when we are done. We use the <a href="https://developer.mozilla.org/en-US/docs/Web/API/DedicatedWorkerGlobalScope/postMessage">postMessage()</a> function for this, which like <code>addEventListener()</code> is a global function in a worker. As we already saw, the main script is listening for this message and will update the DOM when the message is received.</p>
        </article>
        <article>
          <h2>Other types of workers</h2>
          <p>The worker we just created was what's called a dedicated worker. This means it's used by a single script instance.</p>
          <p>There are other types of workers, though:</p>
          <ul>
            <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker" target="_blank">Shared workers</a> can be shared by several different scripts running in different windows.</li>
            <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API" target="_blank">Service workers</a> act like proxy servers, caching resources so that web applications can work when the user is offline. They're a key component of <a href="https://developer.mozilla.org/en-US/docs/Web/Progressive_web_apps" target="_blank">Progressive Web Apps</a>.</li>
          </ul>
        </article>
      </section>
      <!-- End Section -->
    </main>
  </body>
</html>
